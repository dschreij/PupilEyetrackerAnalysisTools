# -*- coding: utf-8 -*-
"""
Created on Wed May  7 16:15:24 2014

@author: Daniel schreij (d.schreij@vu.nl)

This module contains functions to analyze datafiles output by the pupil eyetracker
Currently only datafiles for surfaces can be processed.

The function to start with is analyze_file. This reads in the numpy datafile
generated by the pupil recorder and stores it in a pandas Dataframe. This dataframe
object can then be passed on to most of the other functions to create fixation lists,
heatmaps, etc.

This module can also be executed directly (opposed to importing it). The first
argument should then be the location of the surface_gaze_positions datafile. For
this datafile, the fixation list is then created.
"""

import os, sys
import numpy as np
import pandas as pd
import statsmodels.api as sm
import matplotlib.pyplot as plt
import scipy.ndimage as ndi
import math
import random
import re

#------------------------------------------------------------------------------
# Classes
#------------------------------------------------------------------------------

class InterestArea(object):
	"""Creates a rectangular interest area of specified dimensions at the indicated position.

	Parameters
	----------
	Specify the dimensions of the interest area here. Specify the topleft corner
	in (x,y) and its width and height (w,h) with ints.
	You can do this in one of the following formats:

	- x,y,w,h (4 ints)
	- (x,y)(w,h) (2 tuples with each 2 ints)
	- [(x1,y1),(x2,y2),(x3,y3),(x4,y4)]
	  (1 sequence with 4 points designating te corners of the area
	   starting at the top-left corner and going in clockwise direction.)

	You can also optionally specify the label of this interest area by
	passing the keyword argument 'label' and its value (defaul: Unnamed)

	Raises
	-------
	ValueError: if parameters not supplied in one of the desired formats.
	"""

	def __init__(self, *args, **kwargs):
		"""Constructor"""
		self.set_dimensions(*args)

		# Set default label, to be overwritten by kwarg "label"
		self._label = "Unnamed"

		if kwargs:
			if "label" in kwargs and type(kwargs["label"]) in [str, unicode]:
				self._label = kwargs["label"]

	def __repr__(self):
		return "Interest area \"{4}\": x:{0} y:{1} w:{2} h:{3}".format(self._x, self._y, self._w, self._h, self._label)

	def get_dimensions(self):
		""" Returns positions and dimensions of the interest area
		Returns
		-------
		tuple with (x,y,w,h) (ints)
		"""

		return (self._x, self._y, self._w, self._h)

	@property
	def x(self):
		"""Returns topleft x-coordinate (int) of interest area."""
		return self._x

	@property
	def y(self):
		"""Returns topleft y-coordinate (int) of interest area."""
		return self._y

	@property
	def w(self):
		"""Returns width in pixels (int) of interest area."""
		return self._w

	@property
	def h(self):
		"""Returns height in pixels (int) of interest area."""
		return self._h

	@property
	def label(self):
		"""Returns interest area name."""
		return self._label

	def set_dimensions(self, *args):
		"""Sets the dimensions and/or position of the interest area.

		Parameters
		----------
		Specify the topleft corner in (x,y) and its width and height (w,h) with ints.
		You can do this in one of the following formats:

		- x,y,w,h (4 ints)
		- (x,y)(w,h) (2 tuples with each 2 ints)
		- [(x1,y1),(x2,y2),(x3,y3),(x4,y4)]
		  (1 sequence with 4 points designating te corners of the area
		   starting at the top-left corner and going in clockwise direction.)

		Raises
		-------
		ValueError: if parameters not supplied in desired format
		"""

		# When passed all dimensions (x,y,w,h) in one iterable, such as
		# (1,2,3,4) or [1,2,4,5]
		if len(args) == 1:
			if hasattr(args[0], "__iter__") and len(args[0]) == 4:
				self._x = args[0][0][0]
				self._y = args[0][0][1]
				self._w = args[0][2][0] - self._x
				self._h = args[0][2][1] - self._y
			else:
				raise ValueError("Invalid coordinate format supplied for IA")
		# When passed (x,y) and (w,h) as 2 separate iterables
		if len(args) == 2:
			if hasattr(args[0], "__iter__") and hasattr(args[1], "__iter__") and len(args[0]) == 2 and len(args[1]) == 2:
				self._x = args[0][0]
				self._y = args[0][1]
				self._w = args[1][0]
				self._h = args[1][1]
			else:
				raise ValueError("Invalid coordinate format supplied for IA")
		# When passed x,y,w,h as separate ints
		if len(args) == 4:
			for i in args:
				if not type(i) in [int,float]:
					raise ValueError("Invalid coordinate format supplied for IA")
			else:
				self._x = args[0]
				self._y = args[1]
				self._w = args[2]
				self._h = args[3]

		# Cast to integer, just to be sure
		self._x = int(self._x)
		self._y = int(self._y)
		self._w = int(self._w)
		self._h = int(self._h)

	@x.setter
	def x(self, value):
		"""
		Parameters
		----------
		value : int/float
			the top-left x-coordinate of interest area
		"""
		if type(value) in [int,float]:
			self._x = int(value)
		else:
			raise ValueError("Value must be integer or float")

	@y.setter
	def y(self, value):
		"""
		Parameters
		----------
		value : int/float
			the top-left y-coordinate of interest area
		"""
		if type(value) in [int,float]:
			self._y = int(value)
		else:
			raise ValueError("Value must be integer or float")

	@w.setter
	def w(self, value):
		"""
		Parameters
		----------
		value : int/float
			the width of interest area
		"""
		if type(value) in [int,float]:
			self._w = int(value)
		else:
			raise ValueError("Value must be integer or float")

	@h.setter
	def h(self, value):
		"""
		Parameters
		----------
		value : int/float
			height of interest area
		"""
		if type(value) in [int,float]:
			self._h = int(value)
		else:
			raise ValueError("Value must be integer or float")

	@label.setter
	def label(self, value):
		"""
		Parameters
		----------
		value : str/unicode
			The name of the interest area
		"""
		if type(value) in [str,unicode]:
			self._label = value
		else:
			raise ValueError("Value must be string or unicde")

	def get_corners(self, scale=None):
		""" Calculates x,y coordinates of each corner of the interest area

		Returns
		-------
		tuple with (x,y) coordinate of each corner of the interest area
		"""
		if scale:
			x,y,w,h = self.scale(scale)
		else:
			x,y,w,h = self._x, self._y, self._w, self._h

		top_left = (x,y)
		top_right = (x+w, y)
		bottom_right = (x+w, y+h)
		bottom_left	 = (x, y+h)
		return (top_left, top_right, bottom_right, bottom_left)

	def inside(self, (x,y)):
		""" Checks if the specified point falls inside the interest area's boundaries

		Parameters
		----------
		(x,y) : tuple with 2 ints
			The point to check for if it falls inside the interest area.

		Returns
		-------
		True if point is located inside interest area

		False if point is located outside of interest area
		"""

		area = self.get_corners()

		n = len(area)

		inside = False
		p1x,p1y = area[0]
		for i in range(n+1):
			p2x,p2y = area[i % n]
			if y > min(p1y,p2y):
				if y <= max(p1y,p2y):
					if x <= max(p1x,p2x):
						if p1y != p2y:
							xints = (y-p1y)*(p2x-p1x)/(p2y-p1y)+p1x
						if p1x == p2x or x <= xints:
							inside = not inside
			p1x,p1y = p2x,p2y
		return inside

	def get_center(self):
		"""
		Returns
		-------
		The center x,y of the interest area
		"""
		return (self._x+0.5*self._w, self._y+0.5*self._h)

	def distance_to(self,(x,y)):
		"""Calculates the distance of the supplied point to the center of the IA

		Parameters
		----------
		(x,y) : (int,int) tuple
			Coordinate to calculate distance to

		Returns
		-------
		int : distance to IA center
		"""
		cx,cy = self.get_center()
		return math.hypot(x-cx, y-cy)

	def scale(self, value):
		"""Increase or decrease interest area value by certain ratio.
		This is useful if you want to plot the IAs and the image size you plot on
		is larger or smaller than the image size you specified the IA coords for

		Parameters
		----------
		value : tuple with 2 floats
			[0] The ratio value to enlarge or shrink the IA coordinates with on x-axis and width
			[1] The ratio value to enlarge or shrink the IA coordinates with on y-axis and height

		Raises
		------
		ValueError : if value is other thant a float or int
		"""

		if type(value) == tuple and len(value) == 2:
			x = self._x * value[0]
			y = self._y * value[1]
			w = self._w * value[0]
			h = self._h * value[1]
		else:
			raise ValueError("Scalar value must be tuple with 2 floats")

		return (x,y,w,h)


#------------------------------------------------------------------------------
# Functions
#------------------------------------------------------------------------------

def analyze_files_in_folder(folder, surface_name=None, sacc_threshold=0.9, read_fixations_from_file=False, _sort_result=True):
	"""Travese through folders looking for datafile generated by the pupil eye tracker

	This function recursively traverses through a folder structure looking for pupil data files.
	A good starting point always is the main folder of the recording session.
	For instance if you perform a recording with pupil, it's data structure
	commonly is

	<pupil_folder>/recordings/<session_name>/XXX

	where XXX is a number starting from 000, incrementing with each recording.
	The <session_name> variable will be used for the datafile/participant name
	and the XXX for the trial no.

	Parameters
	----------
	folder : string
		path to the starting folder which to traverse from.

	sacc_threshold : float, default 0.9
		distance threshold above which to count an (x,y) as a saccade.

	Returns
	-------
	pandas.Dataframe with:

		- Filename/participant record
		- Trial no.
		- label of surface
		- index of current frame
		- x on surface (normalized)
		- y on surface (normalized)
		- timestamp of x,y measurement
		- x diff compared to previous trial (hor sacc amplitude)
		- y diff compared to previous trial (ver sacc amplitude)
		- Saccade (did sample occur after saccade (True/False))
		- fixation indices

		Each row in this dataframe corresponds with a sample (which is 24 or
		30 per second depending on the recorder setting)

	Raises
	------
	IOError if folder not found.

	"""
	if not os.path.isdir(folder):
		raise IOError("Folder not found!")

	folder_contents = os.listdir(folder)

	data = None
	fixations = None

	for item in folder_contents:
		# Skip directory specifics
		if item in [".",".."]:
			continue

		item_path = os.path.join(folder,item)

		# If item is a folder, dive into it and restart this process!
		if os.path.isdir(item_path):
			new_data, new_fixations = analyze_files_in_folder(item_path, surface_name, sacc_threshold, read_fixations_from_file, _sort_result=False)
			if not new_data is None:
				if not data is None:
					data = pd.concat([data,new_data], ignore_index=True)
				else:
					data = new_data

			if not new_fixations is None:
				if not fixations is None:
					fixations = pd.concat([fixations,new_fixations], ignore_index=True)
				else:
					fixations = new_fixations

		# If item is a file, check if is the file we are looking for and analyze
		elif os.path.isfile(item_path) and "gaze_positions_on_surface_{0}".format(surface_name) in os.path.split(item_path)[1]:
			sys.stdout.write('.')
			new_data = analyze_file(item_path, sacc_threshold)

			if not new_data is None:
				if not data is None:
					data = pd.concat([data,new_data], ignore_index=True)
				else:
					data = new_data

				if not read_fixations_from_file:
					new_fixations = generate_fixations_list(new_data)

					if not new_fixations is None:
						if not fixations is None:
							fixations = pd.concat([fixations, new_fixations], ignore_index=True)
						else:
							fixations = new_fixations

		elif read_fixations_from_file and os.path.isfile(item_path):
			if not surface_name is None and "fixations_on_surface_{0}".format(surface_name) in os.path.split(item_path)[1]:
				new_fixations = read_fixations_file(item_path, surface_name)
	
				if not new_fixations is None:
					if not fixations is None:
						fixations = pd.concat([fixations, new_fixations], ignore_index=True)
					else:
						fixations = new_fixations
			elif "fixations_on_surface_" in os.path.split(item_path)[1]:
				filename = os.path.split(item_path)[1]
				surface_name = filename.split('_')[3]
				
				new_fixations = read_fixations_file(item_path, surface_name)
				if not new_fixations is None:
					if not fixations is None:
						fixations = pd.concat([fixations, new_fixations], ignore_index=True)
					else:
						fixations = new_fixations

	# Due to the recursive nature of this function, things might not happen in order
	# or in a sorted ways as one might expect. Therefore, explicitly sort the result afterwards
	# Only do this for the top-level function (so not for the recursive calls)
	if _sort_result:
		if not data is None:
			data = data.sort_index(by=['subject_file','trial_no','timestamp']).reset_index(drop=True)
		if not fixations is None:
			fixations = fixations.sort_index(by=['subject_file','trial_no','timestamp']).reset_index(drop=True)
		print "\nFinished"
	return data, fixations

def read_fixations_file(datafile, surface_label):
	"""Reads the fixation file provided by the Pupil Player's fixation detector

	Parameters
	----------
	datafile : string
		path to the fixations_on_surface_{surface_label} datafile to be parsed
	surface_label : string
		The label of the surface of which the file needs to be parsed

	Returns
	-------
	pandas.Dataframe with:

		- general id of fixation (thus also counting fixations outside surface)
		- The subject folder from which these fixations were parsed
		- The subject no.
		- Trial no.
		- label of surface
		- index of current fixation (only counting fixations on surface)
		- fixation duration in milliseconds
		- x on surface (normalized)
		- y on surface (normalized)
		- timestamp of start of fixation

	Raises
	------
	IOError if file not found or file is not a numpy array

	"""
	data = pd.read_csv(datafile, sep="\t")
	if not len(data.index):
		print "\n{0} appears to be empty".format(datafile)
		return None

	# Only keep fixations that were inside a surface
	data = data.query("on_srf == True")
	# If dataframe is empty, issue a warning message and simply return None
	if not len(data.index):
		print "\n{0} has no fixations on surface".format(datafile)
		return None

	data = data.rename(columns={
		"start_timestamp":"timestamp",
		"norm_pos_x":"x",
		"norm_pos_y":"y",
		"duration":"fixation_duration_ms"
		}
	)
	# Go up one folder as pupil exports data to "metrics_xxx" subfolder
	trial_folder = os.path.split(os.path.split(datafile)[0])[0]

	(folder, trial_no) = os.path.split(trial_folder)
	participant = os.path.split(folder)[1]

	# Parse the subject nr from the folder name
	try:		
		subject_nr = int(re.findall(r'\d+',participant)[0])
		data.loc[:,"subject_nr"] = subject_nr
		try:
			phase = int(re.findall(r'\d+',participant)[1])
			data.loc[:,"phase"] = phase
		except:
			pass
		
	except:
		print >> sys.stderr, "\nFile {0}: Could not parse participant number from folder name".format(participant)
		print data
		sys.exit(0)
		
	try:
		data.loc[:,"subject_file"] = participant
		data.loc[:,"trial_no"] = int(trial_no)
		data.loc[:,"surface_label"] = surface_label

	except Exception as e:
		print >> sys.stderr, "\nError reading participant fixations file {}, trial {}: {} (empty data file or no fixations on surface?)\n".format(participant, trial_no, e)
		return None

	# Set fixation indices
	data.loc[:,"fixation_index"] = data.reset_index().index+1
	# Value is normally in seconds, Convert to ms
	data.loc[:,"fixation_duration_ms"] = data["fixation_duration_ms"].astype(float)*1000
	
	columns = ["id","subject_file","subject_nr","trial_no","surface_label",\
	"fixation_index","fixation_duration_ms","x","y","timestamp"]

	try:
		phase
		columns.append('phase')
	except:
		pass
		
	data = data.reindex(columns=columns)
	return data

def analyze_file(datafile, sacc_threshold=0.9):
	"""Analyze the supplied datafile generated by the pupil eye tracker

	This function parses the saccades and the fixations from the list of xy coordinates.
	It creates a CDF of all difference scores for x and y separately.

	Difference scores that fall above the threshold (default 90% or 0.9) will be counted as a saccade
	Needless to say (but doing it anyway) difference scores that fall within the 90% are part of a fixation
	Thus:
	 	- the lower the threshold, the more liberal the saccade detection
		- the higher the threshold, the more conservative the saccade detection

	Parameters
	----------
	datafile : string
		path to the pupil surface datafile to be parsed
	sacc_threshold : float, default 0.9
		Threshold in CDF above which to count diff value as saccade

	Returns
	-------
	pandas.Dataframe with:
		- Filename/participant record
		- Trial no.
		- label of surface
		- index of current frame
		- x on surface (normalized)
		- y on surface (normalized)
		- timestamp of x,y measurement
		- x diff compared to previous trial (hor sacc amplitude)
		- y diff compared to previous trial (ver sacc amplitude)
		- Saccade (did sample occur after saccade (True/False))
		- fixation indices

		Each row in this dataframe corresponds with a sample (which is 24 or
		30 per second depending on the recorder setting)

	Raises
	------
	IOError if file not found or file is not a numpy array
	"""

	# Read in datafile. Exit is file not found
	if not os.path.isfile(datafile):
		raise IOError("File not found. Please specify a valid file location")

	# There's two way the surface data could have been exported
	# 1. During recording by a modification of the pupil software by Daniel, resuling in a .npy file
	#  (this is less and less likely as pupil versions no. increase)
	# 2. By the pupil player, resulting in a .csv file
	# Both ways have different locations at which the data file is placed and assume a different folder structure
	if os.path.splitext(datafile)[1] == ".npy":  # Assume its the surface export data implemented by Daniel
		# Load data into numpy series and create pandas dataframe
		eye_data = np.load(datafile)

		# TEMPORARY FIX. In some recording made by the newer pupil capture software
		# The first column containing the frame indices is missing...
		# In the future, we should only support the offical pupil player output (e.g. the csv mode below)
		# and drop support for our custom .npy format as this becomes way too unpredictable
		try:
			data = pd.DataFrame(eye_data, columns=["frame_index","surface_label","x","y","timestamp"])
		except:
			data = pd.DataFrame(eye_data, columns=["surface_label","x","y","timestamp"])
			data.loc[:,"frame_index"] = data.index.values
		# Parse some extra information from the file path. This sadly isn't included in the datafile itself,
		# so it is absolutely *crucial* to adhere to the pupil folder structure when analyzing data!
		trial_folder = os.path.split(datafile)[0]
	elif os.path.splitext(datafile)[1] == ".csv": # Assume it's the official pupil software's surface data export
		data = pd.read_csv(datafile, sep="\t")
		if not len(data.index):
			print "\n{0} appears to be empty".format(datafile)
			return None
		data = data.query("on_srf == True")
		data = data.rename(columns={"world_frame_idx":"frame_index", "world_timestamp":"timestamp", "x_norm":"x", "y_norm":"y"})
		# Go up one folder as pupil exports data to "metrics_xxx" subfolder
		trial_folder = os.path.split(os.path.split(datafile)[0])[0]
	else:
		raise IOError("File '{0}' has incorrect format or extension".format(datafile))

	# If dataframe is empty, issue a warning message and simply return None
	if not len(data.index):
		print >> sys.stderr, "\n{0} has no samples on surface".format(datafile)
		return None

	(folder, trial_no) = os.path.split(trial_folder)
	participant = os.path.split(folder)[1]

	try:
		data.loc[:,"subject_file"] = participant
		data.loc[:,"trial_no"] = int(trial_no)
	except Exception as e:
		print >> sys.stderr, "\nError reading participant file {}, trial {}: {} (empty data file or no fixations on surface?)".format(participant, trial_no, e)
		return None

	# Parse the subject nr from the folder name
	try:
		subject_nr = int(re.findall(r'\d+',participant)[0])
		data.loc[:,"subject_nr"] = subject_nr
	except:
		print >> sys.stderr, "\nFolder {0}, trial {1}: Could not parse participant number from folder name".format(participant,trial_no)

	# It is nice to set this information as the first two columns, so reindex the dataframe by
	# respecifying the order of columns
	data = data.reindex(columns=["subject_file","subject_nr","trial_no","surface_label","frame_index", "x","y","timestamp"])
	data.x = data.x.astype(float)
	data.y = data.y.astype(float)

	# Timestamps might be read as strings. Convert to floats
	data.loc[:,"timestamp"] = data["timestamp"].astype(float)

	# Subract eye data to calculate difference scores from it
	xy = data[["x","y"]].astype(float).T
	vel_data = np.diff(xy)

	# Insert 0 for the first diff values of the array (for which no scores can be calculated)
	vel_data = np.insert(vel_data, 0, 0.0, axis=1)

	# Add difference scores to array (for now)
	data["x_diff"] = pd.Series(vel_data[0,:].T, index=data.index)
	data["y_diff"] = pd.Series(vel_data[1,:].T, index=data.index)

	# Calculate speed above which to cound x,y shift as saccade
	x_min_sacc_speed = calculate_min_distance(vel_data[0],sacc_threshold)
	y_min_sacc_speed = calculate_min_distance(vel_data[1],sacc_threshold)

	# Get rows at which saccades took place. Increment fixation index value after each saccade
	saccade_rows = (np.abs(vel_data[0]) > x_min_sacc_speed) | (np.abs(vel_data[1]) > y_min_sacc_speed)
	# Get indices of saccade rows. Add 0 to beginning to take in start of first fixation too
	saccades_idx = data[saccade_rows].index.insert(0,data.index[0])

	# Store True at rows at which saccade is assumed to have taken place in column "saccade"
	data["saccade"] = saccade_rows

	# Create a new series containing the fixation index values, to be added to the data array
	# The indices of the series correspond to the indices of the saccades in the data array
	# That is: saccade 1 demarkates the end of fixation 1, sacc 2 for fix 2, etc.
	fixation_indices = pd.Series(data=np.arange(1,len(saccades_idx)+1), index=saccades_idx)
	data["fixation_index"] = fixation_indices

	# At row at which no fixation index was entered the value by default is NaN. Use the
	# handy function bfill and ffill to fill these values with the next occurring saccade index value
	data["fixation_index"].ffill(inplace=True)

	return data

def calculate_min_distance(data, threshold):
	""" Determine the minimum difference score to be counted as a saccade
	by calculating a cummulative distribution of the difference scores. The
	cutoff value is determined by the value of threshold. Any value that falls
	in the cdf range above threshold can be counted as a saccade.

	Parameters
	----------
	data : (Nx2) np.array
		Vector with velocity data

	threshold : float
		The cut-off value above which speeds are counted as saccade

	Returns
	-------
	float : minimum diff value to count as saccade
	"""

	# Remove negative values (convert to positive)
	vel = np.abs(data)
	# Create empirical CDF of velocities
	ecdf = sm.distributions.ECDF(vel)
	# Create the 'bins' by interpolating between the min and max values (1000 points)
	bins = np.linspace(min(vel),max(vel),1000)
	# Get the probability value of each bin
	prob = ecdf(bins)
	# The min sacc speed is the value of the first bin that exceeds the threshold
	min_sacc_speed = bins[prob > threshold][0]

	return min_sacc_speed

def generate_fixations_list(data, strict=True, keep_fix_index=False):
	"""
	Compose a list of fixations from the Dataframe created by analyze_file().
	Additionally calculate the duration of each fixation

	Parameters
	----------
	data : pandas.Dataframe
		output of analyze_file function

	strict : bool, default True
		Due to the low sampling frequency of the pupil
		eye tracker, it is possible that gaze positions that are mid-saccade are
		incorrectly registered as fixations, which have an exceptionally short latency
		of 30 ms. This options specifies if these errononeous fixations should be
		filtered out. (default: True)

	keep_fix_index : bool, default False
		Depends on the value of 'strict'.
		Indicates if the original fixation indices should be kept, or if the filtered
		saccades should be reindexed.

	Returns
	-------

	pandas.Dataframe with:

		- Filename/participant record
		- Trial no.
		- label of surface
		- x on surface (normalized)
		- y on surface (normalized)
		- timestamp of x,y measurement
		- x diff compared to previous trial (hor sacc amplitude)
		- y diff compared to previous trial (ver sacc amplitude)
		- fixation indices
		- fixation durations

		Each row in this dataframe corresponds to a fixation

	"""
	# Get indices of saccade rows. Add 0 to beginning to take in start of first fixation too

	saccade_idx = data[data.saccade == True].index.insert(0,data.index[0])
	# Extract relevant rows from total dataframe and remove saccade column
	fixations = data.ix[saccade_idx].drop("saccade", axis=1)

	# Calculate duration of each fixation. diff takes next element and subtracts the previous.
	# Thus diff actually gives duration of *previous* fixation (index is 1 to high by default)
	# shift(-1) corrects for this.
	fixation_durations = fixations["timestamp"].diff().shift(-1)
	fixations["fixation_duration_ms"] = (fixation_durations*1000).round()

	# Instead of just taking the first (x,y) of each fixation at its start as the gaze position,
	# calculate the average (x,y) of the duration of that fixation, as sometimes
	# there is a small shift in gaze that is not large enough to be counted as a saccade but is
	# a slight displacement in the fixation.

	# Use a pivot table to calculate the average per fixation index
	pt = data.pivot_table(["x","y"],index='fixation_index',aggfunc='mean')
	# Replace the originals with these averaged x,y coords.

	fixations["x"] = pt["x"].values
	fixations["y"] = pt["y"].values

	#The last fixation duration is NaN with this method and needs to be calculated separately
	fixations["fixation_duration_ms"][fixations.index[-1]] = ((data["timestamp"][data.index[-1]] - fixations["timestamp"][fixations.index[-1]])*1000).round()

	# If strict is true, register only the 'probable' fixations (so no < 2 frames duration)
	if strict:
		fixations = fixations[fixations.fixation_duration_ms > 40]
		# Reindex the remaining saccades
		if not keep_fix_index:
			fixations.fixation_index = np.arange(1,len(fixations)+1)

	return fixations


def generate_heatmap(eye_data, size=(1000,1200), surface_image=None, gauss_outflow=20, title=False):
	"""Generates heatmap of supplied samples

	Plots a pyplot.hist2d of the supplied list of samples

	Parameters
	----------
	eye_data : pandas.Dataframe
		With at least the x and y columns of the eye data

	size : tuple of ints
		Dimensions of the plot

	surface_image : string, default None:
		Path to the image to use as the background of the fixation plot

	gauss_outflow : int, default 20
		The extent to which the 'heat' of a fixation flows out to the neighboring pixels
		The lower this number, the more confined the hotspots are to the location of the fixation

	title : bool, default False
		Title to display above graph.
	"""

	# Set plot properties
	plt.figure(figsize=(size[0]/200, size[1]/200))
	plt.xlim(0,size[0])
	plt.ylim(0,size[1])

	# Somehow the hist2d function crashes if the index of the data array does not start with 0,
	# which is not always the case if the data is queried from a larger dataset.
	# Reset the indices of the passed data array just to be sure they always start at 0
	eye_data = eye_data.copy().reset_index()

	h, x_edge, y_edge = np.histogram2d(eye_data.x*size[0], eye_data.y*size[1], bins=(range(size[0]+1), range(size[1]+1)))
	h = ndi.gaussian_filter(h, (30, 30))  ## gaussian convolution

	# First check if image location is specified and exists as a file.
	if not surface_image is None:
		if not type(surface_image) == str:
 			raise TypeError("surface_image must be a path to the image")
		else:
			if not (os.path.isfile(surface_image) and os.access(surface_image, os.R_OK)):
				raise IOError("Image file not found at path or is unreadable (check permissions)")
			else:
				# Flip image upside down
				im = plt.imread(surface_image)
				plt.imshow(im, aspect='auto', extent=[0,size[0], 0, size[1]])

	ax = plt.imshow(h.T)
	ax.set_alpha(0.5)

	if title:
		plt.title(title)



def plot_fixations(fixations, size=(1000,1200), surface_image=None, annotated=True):
	"""Plots the fixations on a surface specified by size. Saccades are shown by lines
	and fixations by circles at the start and end points of these lines. The longer the
	fixation was at a specific point, the bigger the diameter of the circle at that point.

	Parameters
	----------
	fixations : pandas.Dataframe
		This supplied dataframe at least needs to contain the columns:

			- x
			- y
			- fixation_index
			- fixation_duration

	size : tuple, default (1000,1200)
		The space to plot the fixations in. The fixation coordinates inside a surface are
		normalized by the pupil eye tracker so dimensions need to be specified to be able
		to plot them.

	surface_image: string, default None:
		Path to the image to use as the background of the fixation plot

	Raises
	------
	TypeError : if surface_image is not a string to an image
	IOError : if image is not found at specified path
	"""
	plt.figure(figsize=(size[0]/200, size[1]/200))

	plt.xlim(0,size[0])
	plt.ylim(0,size[1])

	# First check if image location is specified and exists as a file.
	if not surface_image is None:
		if not type(surface_image) == str:
 			raise TypeError("surface_image must be a path to the image")
		else:
			if not (os.path.isfile(surface_image) and os.access(surface_image, os.R_OK)):
				raise IOError("Image file not found at path or is unreadable (check permissions)")
			else:
				# Flip image upside down
				im = plt.imread(surface_image)
				plt.imshow(im, aspect='auto', extent=[0,size[0], 0, size[1]])

	# First saccade somehow is almost always logged outside of the surface
	# Discard it if so.
	first_x = fixations["x"].head(1).values[0]
	first_y = fixations["y"].head(1).values[0]
	if first_x < 0 or first_y < 0 or first_x > 1 or first_y > 1:
		fixations = fixations[fixations.fixation_index != 1]

	x_coords = list(fixations["x"]*size[0])
	y_coords = list(fixations["y"]*size[1])

	# Plot the lines representing the fixation displacements (i.e. saccades)
	plt.plot(x_coords, y_coords,'b+-')

	# Plot fixations. The longer the fixation the bigger the radius of its circle
	# Use a scalar value to adapt the relative radius to the size of the plot
	scalar = size[0]/1000.0
	plt.scatter(x=x_coords, y=y_coords, c='r', alpha=0.5, s=scalar*fixations["fixation_duration_ms"], linewidths=1)

	# If required, show the saccade indices next to their data points (slightly offset to the top left)
	if annotated:
		for i in range(len(x_coords)):
			plt.annotate(i+1, xy=(x_coords[i], y_coords[i]), xytext=(-10,10), textcoords = 'offset points')
	plt.show()


def plot_interest_areas(IA_set, reference_size, plot_size, surface_image=None, annotated=True):
	"""Plots the interest areas as designated by IA_set, which should be a sequence of
	pupil.InterestArea objects. It draws them as rectangles in the given size dimensions.
	Optionally, one can provide a surface_image to draw the IAs on.

	Parameters
	----------
	IA_set : sequence of InterestArea objects
		The Interest areas to plot.

	reference_size : tuple
		The reference frame size in which the Interest Area's were determined. For instance,
		if the IAs were drawn/determined on an image of 1200x1000 than the size variable should
		have this value.

	plot_size : tuple
		this contains the x,y dimensions (in px) to plot the fixations in. The fixation coordinates
		inside a surface are normalized (range from 0.0 to 1.0) by the pupil eye tracker so dimensions
		need to be specified to be able to plot them.

	surface_image : string, default None:
		Path to the image to use as the background of the fixation plot

	Raises
	------
	TypeError : if surface_image is not a string to an image

	IOError : if image is not found at specified path
	"""
	scaler = (plot_size[0]/reference_size[0], plot_size[1]/reference_size[1])
	plt.figure(figsize=(plot_size[0]/200, plot_size[1]/200))

	plt.xlim(0,plot_size[0])
	plt.ylim(0,plot_size[1])

	# First check if image location is specified and exists as a file.
	if not surface_image is None:
		if not type(surface_image) == str:
 			raise TypeError("surface_image must be a path to the image")
		else:
			if not (os.path.isfile(surface_image) and os.access(surface_image, os.R_OK)):
				raise IOError("Image file not found at path or is unreadable (check permissions)")
			else:
				# Flip image upside down
				im = plt.imread(surface_image)
				plt.imshow(im, aspect='auto', extent=[0,plot_size[0], 0, plot_size[1]])

	for ia in IA_set:
		x,y = zip(*ia.get_corners(scaler))
		# Add first coordinate again to close shape
		x = list(x) + [x[0]]
		y = list(y) + [y[0]]
		plt.plot(x,y)

		if annotated:
			plt.annotate(ia.label, xy=(x[0],y[0]), xytext=(5,ia.h/4), textcoords = 'offset points')

	plt.show()


def plot_IA_radius(IA_set, radius, size=(1000,1200), surface_image=None, annotated=True):
	"""Plots a circle with radius r around the center of each interest area.
	Optionally, one can provide a surface_image to draw the IAs on.

	Parameters
	----------
	IA_set : sequence of InterestArea objects
		The Interest areas to plot.

	size : tuple, default (1000,1200)
		The space to plot the fixations in. The fixation coordinates inside a surface are
		normalized by the pupil eye tracker so dimensions need to be specified to be able
		to plot them.

	surface_image : string, default None:
		Path to the image to use as the background of the fixation plot

	Raises
	------
	TypeError : if surface_image is not a string to an image

	IOError : if image is not found at specified path
	"""
	scaler = (size[0]/1000.0, size[1]/1200.0)
	plt.figure(figsize=(size[0]/200, size[1]/200))

	plt.xlim(0,size[0])
	plt.ylim(0,size[1])

	# First check if image location is specified and exists as a file.
	if not surface_image is None:
		if not type(surface_image) == str:
 			raise TypeError("surface_image must be a path to the image")
		else:
			if not (os.path.isfile(surface_image) and os.access(surface_image, os.R_OK)):
				raise IOError("Image file not found at path or is unreadable (check permissions)")
			else:
				# Flip image upside down
				im = plt.imread(surface_image)
				plt.imshow(im, aspect='auto', extent=[0,size[0], 0, size[1]])

	gcf = plt.gcf()
	for ia in IA_set:
		x,y = ia.get_center()
		x *= scaler[0]
		y *= scaler[1]

		circle=plt.Circle((x,y),radius, color=random.choice(['r','g','b','y']), clip_on=False)
		circle.set_alpha(0.25)
		gcf.gca().add_artist(circle)

		if annotated:
			plt.annotate(ia.label, xy=(x,y), xytext=(-len(ia.label)*2,0), textcoords = 'offset points')

	plt.show()

def assign_fixations_to_IAs(fix_list, IAs, scaler, column_name="interest_area"):
	"""Determines if a fixation falls within a certain interest area, and if so
	assigns this IA to the row of this fixation in the passed fixations dataframe.

	Parameters
	----------
	fix_list : pandas.Dataframe
          List of fixations. Preferred is the output format of
	        generate_fixations_list()
	    but can be any arbitrary dataframe in which a single row corresponds
	    to a fixation. This dataframe should at least have a "x" and "y" column
	    representing these coordinates of the fixation.
	IAs : sequence of InterestArea objects
	scaler : 2xint tuple
		The dimensions with which to scale the normalized x,y coordinates (as pupil
		stores them in the datafile)

	Returns
	-------
	pandas.Dataframe, which is the passed fix_list with the interest_area column added

	Raises
	------
	TypeError : if surface_image is not a string to an image

	IOError : if image is not found at specified path
	"""

	# Initialze
	fix_list[column_name] = "None"
	for row in fix_list.iterrows():
		index = row[0]
		data = row[1]

		coord = (data["x"]*scaler[0], data["y"]*scaler[1])

		for ia_candidate in IAs:
			if ia_candidate.inside(coord):
				fix_list.loc[index,column_name] = ia_candidate.label
				break
	return fix_list

def calculate_distance_to_target(fix_list, IAs, target_col_label, scaler):
	"""Calculates the distance of each fixation to the target item of a trial.

	Parameters
	----------
	fix_list : pandas.Dataframe
		List of fixations. Preferred is the output format of

		generate_fixations_list()

		but can be any arbitrary dataframe in which a single row corresponds
		to a fixation. This dataframe should at least have a "x" and "y" column
		representing the coordinates of the fixation and a column "target".
	IAs : list or tuple
		sequence of InterestArea objects
	target_col_label : string
		The name of the column of fix_list in which the name of the target item is stored.
	scaler : 2xint tuple, optional
		The dimensions with which to scale the normalized x,y coordinates (as pupil
		stores them in the datafile). The first item scales the x vector, the second
		the y vector. Basically this is the size of the surface image.

	Returns
	-------
	pandas.Dataframe, which is the passed fix_list with the distance column added

	Raises
	------
	TypeError : if surface_image is not a string refering to an image location
	"""

	if not target_col_label in fix_list.columns:
		raise TypeError("Target label column not found in supplied dataframe")

	current_trial = None
	fix_list["distance_to_target"] = np.NaN

	for index, row in fix_list.iterrows():
		# If new trial starts, the new target IA needs to be determined
		if row["trial_no"] != current_trial:
			current_trial = row["trial_no"]
			# Find the IA corresponding to the target's
			try:
				current_target_IA = next(ia for ia in IAs if ia.label == row[target_col_label])
			except StopIteration:
				#raise LookupError("Could not find the specified interest area {0}".format(row[target_col_label]))
				print "No IA found for {0}".format(row[target_col_label])
				current_target_IA = None

		if current_target_IA:
			x = row["x"]*scaler[0]
			y = row["y"]*scaler[1]
			fix_list.loc[index,"distance_to_target"] = current_target_IA.distance_to((x,y))
	return fix_list

def calculate_scan_path_ratios(fix_list, scale=(1.0,1.0), till_first_t_fixation=True, min_distance_to_target=None):
	"""Composes a dataframe of trials with the calculated scanpath ratio for each trial
	The scanpath ratio basically is the total_lenght_of_saccades divided by the shortest distance
	of the first saccade to the center of the target IA.

	Parameters
	----------
	fix_list : pandas.Dataframe containing fixations
		The dataframe should at least contain the following columns:

		- subject_file
		- trial_no
		- x
		- y
		- on_target (specifying if fixation is on target (True/False))
		- distance_to_target

	scale : (int,int) tuple, default (1.0,1.0)
		The scalars to use on the normalized x,y coordinates (as pupil supplies them)

	till_first_t_fixation : boolean, default True
		Stop calculating the total saccade distance once the target IA is fixated for the first time

	min_distance_to_target : int, default None
		Specify this to use a minimum distance between fixation and target IA center to determine if
		the target is fixated. If 'None' is specified, then the inside() function of the IA will be used
		to see if a fixation fell in the IA

	Returns
	-------
	pandas.Dataframe : a per participant, per trial calculation of the scanpath ratio
		The dataframe will contain the following columns

		- subject_file
		- subject_nr
		- trial_no
		- no_of_saccades
		- sum_saccade_distance
		- min_first_sacc_to_target
		- scanpath_ratio
		- epoch (if present in input df)
		- block (if present in input df)

	Raises
	------
	TypeError : if min_distance_to_target is not an int, float or the default None

	ValueError : if min_distance_to_target is smaller than 0
	"""

	if not min_distance_to_target is None:
		if not type(min_distance_to_target) in [int,float]:
			raise TypeError("min_distance_to_target needs to be an int, float, or None")
		elif min_distance_to_target < 0:
			raise ValueError("min_distance_to_target needs to be larger than 0")


	cols = ["subject_file","subject_nr","trial_no","no_of_saccades","sum_saccade_distance","dist_first_sacc_to_target","scanpath_ratio","t_to_first_target_fix"]
	if "epoch" in fix_list.columns:
		cols.append("epoch")
	if "block" in fix_list.columns:
		cols.append("block")

	scan_path_df = pd.DataFrame(columns=cols)
	total_count = 0
	error_count = 0

	# Iterate through each participant
	for subject in fix_list["subject_file"].unique():
		# Iterate through each trial of participant
		for trial in fix_list[fix_list['subject_file']==subject]["trial_no"].unique():
			# The current data chunk to work on
			q = "subject_file=='{0}' and trial_no=={1}".format(subject,trial)
			current_data = fix_list.query(q)
			# Distance of first fixation inside surface to the target
			dtt = current_data.head(1)["distance_to_target"].values[0]
			start_time = current_data.head(1)["timestamp"].values[0]
			subject_nr = current_data.head(1)["subject_nr"].values[0]

			last_fixation = None
			total_sacc_distance = 0
			sacc_counter=0
			total_count += 1

			# Iterate through each fixation
			for i, fixation in current_data.iterrows():
				# last_fixation is None for first fixation
				if not last_fixation is None:
					x1,y1 = last_fixation["x"],last_fixation["y"]
					x2,y2 = fixation["x"],fixation["y"]
					total_sacc_distance += math.hypot((x2-x1)*scale[0],(y2-y1)*scale[1])
				last_fixation = fixation
				sacc_counter+=1

				# Stop if indicated that spr should be calculated till first fixation inside target IA
				# and current fixation falls within target IA
				if till_first_t_fixation:
					if not min_distance_to_target is None and fixation["distance_to_target"] < min_distance_to_target:
						break
					elif fixation["on_target"] == True:
						break
			else:
				# If a break did not occur (and thus there was apparently no fixation on the target item this trial)
				# you might want to flag this trial as erroneous. Especially if till_first_t_fixation is True.
				if till_first_t_fixation:
					print >> sys.stderr, "Participant {0}, trial {1}: No fixation on target detected".format(subject,int(trial))
					# Quit for this trial, don't add it to the list
					error_count += 1
					continue

			new_row = {
				"subject_file": subject,
				"subject_nr": subject_nr,
				"trial_no": trial,
				"no_of_saccades" : sacc_counter,
				"sum_saccade_distance":total_sacc_distance,
				"dist_first_sacc_to_target":dtt,
				"scanpath_ratio": total_sacc_distance/float(dtt),
				"t_to_first_target_fix": (last_fixation["timestamp"]-start_time)*1000
			}

			if "epoch" in cols:
				new_row["epoch"] = current_data["epoch"].head(1).values[0]
			if "block" in cols:
				new_row["block"] = current_data["block"].head(1).values[0]

			scan_path_df = scan_path_df.append(new_row, ignore_index=True)

	print "Finished with {0} errors".format(error_count)
	print "{0}% of the trials discarded".format(int(1.0*error_count/total_count*100))
	print "\n"

	# Do some typecasting
	scan_path_df[["no_of_saccades","sum_saccade_distance","dist_first_sacc_to_target","scanpath_ratio","t_to_first_target_fix"]] = scan_path_df[["no_of_saccades","sum_saccade_distance","dist_first_sacc_to_target","scanpath_ratio","t_to_first_target_fix"]].astype(float)
	return scan_path_df

def calculate_incidental_gaze_durations(fix_list, min_distance_to_target=None, ia_label="interest_area"):
	results = pd.DataFrame(columns=["subject_file", "object", "incidental_gaze_duration", "first_fix_time", "target_fix_index"])
	curr_participant = None

	for index, fixation in fix_list.iterrows():
		if fixation["subject_file"] != curr_participant:
			curr_participant = fixation["subject_file"]
			passed_targets = []
			curr_trial_no = 0

		# Detect if current fixation belongs to a new trial
		if fixation["trial_no"] != curr_trial_no:
			# Reset some variables for current trial
			curr_trial_no = fixation["trial_no"]
			# Indicates if target has been fixated in this trial
			# Rest to False here (as a new trial has just begun)
			target_fixated = False

			# Start time of this trial
			start_time = fixation["timestamp"]

		# Interest area of current fixation
		ia = fixation[ia_label]

		# Check if target has been fixated  before, so below code is only
		# executed for first fixation on target, and not on later subsequent
		# fixations in the same trial.
		if not target_fixated:
			if type(min_distance_to_target) in [float,int]:
				if fixation["distance_to_target"] < min_distance_to_target:
					target_fixated = True
			elif fixation["on_target"]:
				target_fixated = True

			# If current fixation is on the target, store the fixation arrival time
			if target_fixated:
				if not fixation["target"] in results["object"][results.subject_file==curr_participant].values:
					results = results.append({"subject_file":curr_participant, "object": fixation["target"], "incidental_gaze_duration":0, "first_fix_time": (fixation["timestamp"] - start_time) * 1000, "target_fix_index": fixation["fixation_index"] }, ignore_index=True)
				else:
					rows = (results["object"] == fixation["target"]) & (results["subject_file"] == curr_participant)
					results.loc[rows, "first_fix_time"] = (fixation["timestamp"] - start_time) * 1000
					results.loc[rows, "target_fix_index"] = fixation["fixation_index"]
				# Append previous target to passed targets array
				passed_targets.append(fixation["target"])

		# Calculate accidental gaze durations for non-target objects
		if ia not in passed_targets and ia != "None":
			if not ia in results["object"][results.subject_file==curr_participant].values:
				results = results.append({"subject_file":curr_participant, "object":ia, "incidental_gaze_duration":0, }, ignore_index=True)
			results.loc[(results["object"] == ia) & (results["subject_file"] == curr_participant), "incidental_gaze_duration"] += fixation["fixation_duration_ms"]
	return results.convert_objects(convert_numeric=True)



#------------------------------------------------------------------------------
# Main script when module is called to run directly
#------------------------------------------------------------------------------

if __name__ == "__main__":
	if len(sys.argv)	< 2:
		print "Please supply data file location"
	else:
		datafile = sys.argv[1]

		try:
			if os.path.isfile(datafile):
				# Get data from numpy file
				eye_data = analyze_file(datafile,0.9)

				# Compose a list of fixations
				fixations = generate_fixations_list(eye_data)

				eye_data.to_csv(os.path.join(os.getcwd(),"raw_data.csv"), index=False)
				fixations.to_csv(os.path.join(os.getcwd(),"fixations.csv"), index=False)

			# If a folder is given as argument, traverse it while looking for datafiles
			if os.path.isdir(datafile):
				eye_data = analyze_files_in_folder(datafile, 0.9)

				# Write data to csv file
				eye_data.to_csv(os.path.join(os.getcwd(),"raw_data.csv"), index=False)

		except IOError as e:
			print >> sys.stderr, e.message
			sys.exit(1)





